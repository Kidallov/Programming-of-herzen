В первом задании было выполнено следующее:

Элементы, которые убраны:
1. Явное закрытие файлов через `f.close()`:
   - Убрал явные вызовы `f.close()` после операций с файлами.
   - Вместо этого использован контекстный менеджер `with`, который автоматически закрывает файл даже при возникновении исключений.

2. Прямое использование `eval` без обработки ошибок:
   - Ранее `eval` использовался без проверки, что могло приводить к ошибкам, если данные в файле настроек были некорректными. 

3. Необработанные исключения:
   - В старом коде некоторые ошибки (например, отсутствие файла настроек или проблемы записи в файл) могли вызвать необработанное исключение и остановить программу.

4. **Пустой `try` без `else` и `finally`:**
   - В оригинальном коде не использовались блоки `else` и `finally` для выполнения операций после успешного выполнения `try` или в любых условиях.

Элементы, которые добавлены:
1. Контекстные менеджеры (`with open(...)`):
   - Использован `with` для работы с файлами, чтобы автоматизировать закрытие файлов после завершения операций.

2. Обработка ошибок при вызове `eval`:
   - Добавлен отдельный `try...except` внутри обработки параметров для отлова ошибок преобразования данных.

3. Блоки `try...except...else...finally`:
   - Для операций чтения и записи в файл добавлены полные конструкции:
     - **`else`:** Выполняется, если исключения не было.
     - **`finally`:** Гарантирует выполнение определенных операций (например, возврат параметров даже при ошибках).

4. Обработка ошибок отсутствия файла и прав доступа:
   - Для функции `load_params` добавлены проверки:
     - **`FileNotFoundError`:** Если файл настроек отсутствует.
     - **`PermissionError`:** Если недостаточно прав для доступа к файлу.

5. Обработка исключений при записи в файл:
   - Для функции `write_log` добавлена попытка создания резервного файла, если запись в основной файл невозможна.

6. Обработка ошибок ввода данных в `calculate`:
   - Если переданы некорректные аргументы (например, строки вместо чисел), вызывается исключение `TypeError`, которое обрабатывается с выводом сообщения.

7. Пользовательские сообщения об ошибках:
   - Добавлены информативные сообщения для пользователя, описывающие причину и место возникновения ошибки (например, "Ошибка загрузки параметров" или "Ошибка записи лога").




Во втором задании было выполнено следующее:

В функции "fact" должна быть реализована логика для вычисления факториала числа. Мы добавим обработку случаев для отрицательных чисел, а также реализуем сам расчет факториала для корректных входных данных. И покроем тестами все возможные случаи: отрицательные числа, ноль, положительные числа, и исключения.

Функция "fact":

Если n < 0, выбрасываем исключение ValueError с понятным сообщением.
Если n == 0, возвращаем 1 (по определению факториала).
Если n > 0, вычисляем факториал через цикл.

Тесты:

test_neg_values_fact: Проверяет, что передача отрицательного числа вызывает исключение ValueError.

test_neg_values_fact_ex_text: Проверяет, что текст исключения содержит фразу "больше либо равно нулю".

test_zero_fact: Проверяет, что факториал 0 возвращает 1.

test_positive_fact: Проверяет, что факториал работает корректно для небольших положительных чисел.

test_large_number_fact: Проверяет, что факториал работает корректно для более крупных чисел.

Запуск тестов:

Запускаем тесты через unittest.main(verbosity=2). Параметр verbosity=2 обеспечивает подробный вывод результатов тестирования.



При корректной реализации все тесты должны пройти успешно. Вывод будет выглядеть примерно так:

test_large_number_fact (__main__.TestSomeFunc) ... ok
test_neg_values_fact (__main__.TestSomeFunc) ... ok
test_neg_values_fact_ex_text (__main__.TestSomeFunc) ... ok
test_positive_fact (__main__.TestSomeFunc) ... ok
test_zero_fact (__main__.TestSomeFunc) ... ok

----------------------------------------------------------------------
Ran 5 tests in 0.001s

OK






В третьем задании было выполнено следующее:


Преимущества pytest:
Более лаконичный синтаксис — нет необходимости создавать классы для тестов.
Автоматическое обнаружение тестов, если их названия начинаются с test_.
Улучшенный вывод информации при провале тестов.
Поддержка параметризации тестов, что упрощает тестирование с разными входными данными.
